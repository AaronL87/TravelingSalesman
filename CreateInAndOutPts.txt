from scipy.spatial import ConvexHull
import numpy as np
from math import sqrt

AllPoints = []
radius_list = []

n=10 # number of points
N=25 # +/- range [input should be even] of points 
 
while len(AllPoints) < n:
  points = (float(np.random.randint(-N,N)),float(np.random.randint(-N,N)))
  AllPoints.append(points)
# creates list of random points {couldn't use For Loop because randomness didn't work}
 
print("AllPoints:", AllPoints,"\n"*2)
 
hull = ConvexHull(AllPoints)

Outer_Pts = [AllPoints[i] for i in hull.vertices]
Inner_Pts = [x for x in AllPoints if x not in Outer_Pts]

print("OUTER:",Outer_Pts,"\n")
print("INNER:",Inner_Pts,"\n"*2)

'''
TODO maybe
class Points():
  def Outer_Pts():

  def Inner_Pts():
'''

def Min_Dist_Calc(In_Points,CrntBndPts): #Finds minimum distance from each outer point to each inner point and collects them
  Dict = {} #TODO put condition in for case with no Inner_Pts
  for (i,j) in CrntBndPts:
    List = []
    Crnt_Min = float()
    for (x,y) in In_Points:
      Check_Dist = float(sqrt((x-i)**2 + (y-j)**2))
      radius_list.append(Check_Dist) #TODO may not need to be here    
      if len(List) == 0:
        Crnt_Min = Check_Dist
        List.append((x,y))  
      else:
        if Crnt_Min == Check_Dist:
          List.append((x,y))          
        elif Crnt_Min >= Check_Dist:
          del List[:]
          List.append((x,y))
          Crnt_Min = Check_Dist 
        else:
          pass
    Dict.update({((i,j),Crnt_Min):List}) 
  print("Dist_Dict:",Dict,"\n")  
  return Dict

def residual_ConnectInner_finder(Big_Radius,Smallest_Dict_Entry,In_Points,Inner_Connect):
  Next_Smallest = 0
  radius_iter = []
  radius_iter.append(Big_Radius)
  "Inner_Connect = []" #TODO may need to stay or delete
  for x in radius_iter:
    print("radius_iter_main:",x)
    while Next_Smallest <= x:
      Inner_Connect = [x for [x] in Smallest_Dict_Entry.values()] + Inner_Connect
      In_Points = [x for x in In_Points if x not in Inner_Connect]
      print("Inner_Connect:",Inner_Connect,"\n")
      print("In_Points:",In_Points,"\n"*2)
      
      if len(In_Points) == 0: #TODO Needs to cycle again through Inner_Connect to connect to two points
        print("No Inner_Pts Remaining")
        return Inner_Connect, radius_iter 
      else:
        pass
      
      Dist_Dict_Temp = Min_Dist_Calc(In_Points,Inner_Connect)

      if min(y for (x,y) in Dist_Dict_Temp.keys()) <= x: 
        Next_Smallest = min(y for (x,y) in Dist_Dict_Temp.keys()) # TODO Might be able to put these two lines into Min_Dist_Calc
        print("Next_Smallest:",Next_Smallest,"\n")
        radius_iter.append(Next_Smallest)
        print("radius_iter_sub:",radius_iter)
        x = min(radius_iter)
        Smallest_Dict_Entry = {((a,b),c):d for ((a,b),c),d in Dist_Dict_Temp.items() if c == Next_Smallest}
        print("Smallest_Dict_Entry:",Smallest_Dict_Entry,"\n"*2)
      else:
        z = min(y for (x,y) in Dist_Dict_Temp.keys())
        print(z)
        print("NO NEXT SMALLEST","\n"*2)
        break
    
    #TODO Cycles through this part an extra time
    print("radius_iter before sort:",radius_iter)
    radius_iter.sort() # Reverses order to have ascending radii
    Next_Smallest = x
    print("radius_iter final:",radius_iter) 
    continue
    
  return Inner_Connect, radius_iter #TODO store Inner_Connect to see when another Outer or Inner_Connect reaches it"""
# calculates to see if new inner point(s) is within same distance to another inner point

def Dict_Sorter(Big_Radius,Smallest_Dict_Entry,In_Points,Inner_Connect): # Classifies "Shortest" Dict entry
  if len(Smallest_Dict_Entry) > 1 or len(Smallest_Dict_Entry.values()) > 1:
    pass

  else:
    Inner_Connect, radius_iter = residual_ConnectInner_finder(Big_Radius,Smallest_Dict_Entry,In_Points,Inner_Connect)
    return Inner_Connect, radius_iter


Dist_Dict = Min_Dist_Calc(Inner_Pts,Outer_Pts)

Outer_Radius = min(y for (x,y) in Dist_Dict.keys())
Shortest = {((a,b),c):d for ((a,b),c),d in Dist_Dict.items() if c == Outer_Radius}
print("Outer_Radius:",Outer_Radius,"\n")
print("Shortest:",Shortest,"\n"*2)
#finds distance to closest inner point from any outer point

Connected_Inner = []
radius_list = [Outer_Radius]

Connect_In, radi_iteration = Dict_Sorter(Outer_Radius, Shortest,Inner_Pts,Connected_Inner)

'''
for x in radius_list:
  Connect_In, radi_iteration = Dict_Sorter(x, Shortest,Inner_Pts,Connected_Inner)
  if radi_iteration != None:
    radius_list = radius_list + radi_iteration
'''
'''
if any(Connected_Inner0) == any(Connected_Inner1):
  List = (x, y for x in Connected_Inner0 for y in Connected_Inner1 if x == y)
  Outer_Pts = Outer_Pts + List
'''

"""
 
 
Have all IP_n that are contacted in the process of 
Whenever two OP_n contact the same point in this process, break the outer link (OL_n-i,n-j) between OP_n, keeping all inner links (IL_n-i,n-j) that were created when XR (any radius) touched IP_n
Similarly, break IL_n-i,n-j when IR_n-i and IR_n-j both contact any IP_nc"""
