from scipy.spatial import ConvexHull
import numpy as np
from math import sqrt

AllPoints = []

n=15 # number of points
N=10 # +/- range of points 
 
for i in range(n):
  points = (float(np.random.randint(-N,N)),float(np.random.randint(-N,N)))
  AllPoints.append(points)
# creates list of random points

AllPoints = list(set(AllPoints)) #takes out possible duplicates

print("AllPoints:", AllPoints,"\n"*2)
 
hull = ConvexHull(AllPoints)

Outer_Pts = [AllPoints[i] for i in hull.vertices]
Inner_Pts = [x for x in AllPoints if x not in Outer_Pts]

print("OUTER:",Outer_Pts,"\n")
print("INNER:",Inner_Pts,"\n"*2)

current_edges = [(Outer_Pts[i],Outer_Pts[(i+1)%len(Outer_Pts)]) for i in range(len(Outer_Pts))]
print("current_edges:",current_edges,"\n"*2)

#Two boundary points will never connect apart from current edges
#Subtract outer radius from outer_pts/connect points connection, and subtract associated distance from each entry in Short_List
#Continue to include outer points in each shortest iteration, but eliminate key-point and include current_edges restriction.

def Min_Dist_Calc(In_Points,CrntBndPts): #Finds minimum distance from each In_Points to any CrntBndPts
  Dict = {} 
  '''
  Short_Keys = [a for (a,b) in short_iter.keys]
  '''
  for (i,j) in CrntBndPts:
    List = []
    Crnt_Min = float()
    for (x,y) in In_Points:
      '''
      if (i,j) == (x,y) or (x,y) is in Short_Keys: #TODO make sure points don't subtract from themselves or the previous point
        continue
      '''
      Check_Dist = float(sqrt((x-i)**2 + (y-j)**2))
      # TODO need minimum distance to all non-connected points for checking distance by subtracting current outer radius from minimum distance and seeing if that is smaller than next smallest
      '''
      if CrntBndPts == Inner_Connect:  
        if (x,y) is in Outer_Pts:
          Check_Dist = Check_Dist - Outer_Radius
        elif (x,y) is in Inner_Connect: 

      if CrntBndPts == Combined_Connect:
        if (x,y) is in Outer_Pts:
          Check_Dist =
      '''
      
      if len(List) == 0:
        Crnt_Min = Check_Dist
        List.append((x,y))  
      else:
        if Crnt_Min == Check_Dist:
          List.append((x,y))          
        elif Crnt_Min >= Check_Dist:
          del List[:]
          List.append((x,y))
          Crnt_Min = Check_Dist 
        else:
          pass
    Dict.update({((i,j),Crnt_Min):List}) 
  print("Dist_Dict:",Dict,"\n")   
  return Dict

def Sorter_Func(In_Points, CrntBndPts, short_iter): #returns through all functions once there are no more inner points
  if len(In_Points) == 0: 
    print("No Inner_Pts Remaining","\n"*2)
    return None,None,short_iter
  else:
    pass

  Dist_Dict = Min_Dist_Calc(In_Points,CrntBndPts)

  Outer_Radius = min(y for (x,y) in Dist_Dict.keys())
  Shortest = {((a,b),c):d for ((a,b),c),d in Dist_Dict.items() if c == Outer_Radius}
  print("Outer_Radius:",Outer_Radius,"\n")
  print("Shortest:",Shortest,"\n"*2)

  return Shortest,Outer_Radius,short_iter

def Connect_Func(In_Points,CrntBndPts,Short_List): #cycles through all radii that occur in process of the In_Points' radii catching up to the (largest) Outer_Radius
  Next_Smallest = 0
  radius_iter = []
  short_iter = []

  Shortest,Outer_Radius,short_iter = Sorter_Func(In_Points,CrntBndPts,short_iter)

  if Shortest == None:
    Short_List = Short_List + short_iter
    print("Short_List:",Short_List,"\n"*2)
    return None,None,Short_List

  short_iter.append(Shortest) #used for second cycle through points
  print("short_iter:",short_iter,"\n"*2)
 
  Inner_Connect = list(set([y for x in Shortest.values() for y in x])) #Adds connect points
  In_Points = [x for x in In_Points if x not in Inner_Connect] #removes connected point from in_points
  print("Inner_Connect:",Inner_Connect,"\n")
  print("In_Points:",In_Points,"\n"*2)

  radius_iter.append(Outer_Radius)
  
  for x in radius_iter:
    print("radius_iter_main:",x)
    while Next_Smallest <= x:
      
      Dist_Dict_Temp,Smallest,short_iter = Sorter_Func(In_Points,Inner_Connect,short_iter)

      if Dist_Dict_Temp == None:
        Short_List = Short_List + short_iter
        print("Short_List:",Short_List,"\n"*2)
        return Inner_Connect,None,Short_List

      if Smallest <= x: #when next point is closer than smallest current radius
        # TODO if statement to compare to distance to other connected points minus large radius
        Next_Smallest = Smallest 
        print("Next_Smallest:",Next_Smallest,"\n")
        radius_iter.append(Next_Smallest)
        radius_iter = list(set(radius_iter))
        print("radius_iter_sub:",radius_iter)
        x = Next_Smallest 
        Shortest = {((a,b),c):d for ((a,b),c),d in Dist_Dict_Temp.items() if c == Next_Smallest}
        print("Shortest:",Shortest,"\n"*2)

        short_iter.append(Shortest) #used for second cycle through points
        print("short_iter:",short_iter,"\n"*2)

        Inner_Connect = list(set([y for x in Shortest.values() for y in x])) + Inner_Connect
        In_Points = [x for x in In_Points if x not in Inner_Connect]
        print("Inner_Connect:",Inner_Connect,"\n")
        print("In_Points:",In_Points,"\n"*2)
      else: #when next point is further away than smallest current radius
        z = min(y for (x,y) in Dist_Dict_Temp.keys())
        print(z)
        print("NO NEXT SMALLEST","\n"*2)
        break
    
    radius_iter.sort() # Reverses order to have ascending radii
    Next_Smallest = x
    print("radius_iter final:",radius_iter,"\n"*2) 
    continue

  Short_List = Short_List + short_iter
  print("Short_List:",Short_List,"\n"*2) 
  return Inner_Connect,In_Points,Short_List #TODO store Inner_Connect to see when another Outer or Inner_Connect reaches it"""
# calculates to see if new inner point(s) is within same distance to another inner point

Short_List = []

Connect_In,Inner_Pts,Short_List = Connect_Func(Inner_Pts,Outer_Pts,Short_List)

def Big_Cycle(Connect_In,Inner_Pts,Short_List): #cycles through all connections of original boundary points until there are no more inner points
  if Connect_In == None: 
    return
  else:
    while Inner_Pts != None:
      Combined_Connect = Connect_In + Outer_Pts
      print("OUTER:",Outer_Pts,"\n")
      print("Combined_Connect:",Combined_Connect,"\n")
      print("INNER:",Inner_Pts,"\n"*2)
      Connect_In,Inner_Pts,Short_List = Connect_Func(Inner_Pts,Combined_Connect,Short_List)
      if Inner_Pts == None:
        break
  return

Big_Cycle(Connect_In,Inner_Pts,Short_List)

'''
class polygon:
  class vertices:
    def __init__(self,point):

    def intake(self):  

  class edges:
    def __init__(self,point1,point2):

    def create_edge(self):
  
Outer_Pts
Inner_Pts
'''

'''
while current_edges != n
'''
"""
Have all IP_n that are contacted in the process of 
Whenever two OP_n contact the same point in this process, break the outer link (OL_n-i,n-j) between OP_n, keeping all inner links (IL_n-i,n-j) that were created when XR (any radius) touched IP_n
Similarly, break IL_n-i,n-j when IR_n-i and IR_n-j both contact any IP_nc
"""
